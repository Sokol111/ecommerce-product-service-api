#!/usr/bin/env bash
# ============================================================================
# Event Code Generator
# ============================================================================
# Generates Go code from AsyncAPI spec and Avro schemas.
# This script mirrors the GitHub workflow build-asyncapi.yml
#
# Usage: ./scripts/generate-events.sh [options]
#   -a, --asyncapi FILE   AsyncAPI spec file (default: asyncapi/asyncapi.yaml)
#   -s, --schemas DIR     Avro schemas directory (default: avro)
#   -o, --output DIR      Output directory (default: events)
#   -p, --package NAME    Go package name (default: events)
#   -h, --help            Show this help
# ============================================================================

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Default values
ASYNCAPI_FILE="asyncapi/asyncapi.yaml"
AVRO_DIR="avro"
OUTPUT_DIR="events"
PACKAGE="events"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--asyncapi) ASYNCAPI_FILE="$2"; shift 2 ;;
        -s|--schemas) AVRO_DIR="$2"; shift 2 ;;
        -o|--output) OUTPUT_DIR="$2"; shift 2 ;;
        -p|--package) PACKAGE="$2"; shift 2 ;;
        -h|--help)
            head -20 "$0" | grep -E "^#" | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        *) echo -e "${RED}Unknown option: $1${NC}"; exit 1 ;;
    esac
done

log() { echo -e "${GREEN}✓${NC} $1"; }
warn() { echo -e "${YELLOW}⚠${NC} $1"; }
error() { echo -e "${RED}✗${NC} $1"; exit 1; }

# Check required tools
check_tools() {
    log "Checking required tools..."
    
    command -v avrogen >/dev/null 2>&1 || error "avrogen not found. Install: go install github.com/hamba/avro/v2/cmd/avrogen@latest"
    command -v yq >/dev/null 2>&1 || error "yq not found. Install: brew install yq / sudo apt install yq"
    command -v jq >/dev/null 2>&1 || error "jq not found. Install: brew install jq / sudo apt install jq"
}

# Create output directory
create_output_dir() {
    log "Creating output directory: $OUTPUT_DIR"
    mkdir -p "$OUTPUT_DIR"
    mkdir -p "$OUTPUT_DIR/schemas"
}

# Generate Go types from Avro schemas
generate_avro_types() {
    log "Generating Go types from Avro schemas..."
    
    # Build list of schemas with proper ordering (EventMetadata first)
    local all_schemas=""
    
    if [ -f "$AVRO_DIR/event_metadata.avsc" ]; then
        all_schemas="$AVRO_DIR/event_metadata.avsc"
    fi
    
    for schema in "$AVRO_DIR"/*.avsc; do
        if [ "$(basename "$schema")" != "event_metadata.avsc" ]; then
            all_schemas="$all_schemas $schema"
        fi
    done
    
    # shellcheck disable=SC2086
    avrogen -pkg "$PACKAGE" \
        -o "$OUTPUT_DIR/types.gen.go" \
        -tags json:snake \
        $all_schemas
    
    log "Generated: $OUTPUT_DIR/types.gen.go"
}

# Generate constants from Avro schemas and AsyncAPI spec
generate_constants() {
    log "Generating constants..."
    
    local output_file="$OUTPUT_DIR/constants.gen.go"
    
    cat > "$output_file" << EOF
// Code generated by generate-events.sh. DO NOT EDIT.
package $PACKAGE

import "reflect"

// Event type constants - match Avro schema names
const (
EOF

    # Generate EventType constants from schema names
    for schema in "$AVRO_DIR"/*.avsc; do
        local schema_name
        schema_name=$(jq -r '.name' "$schema" 2>/dev/null || echo "")
        
        if [[ "$schema_name" == *"Event" ]]; then
            # ProductCreatedEvent -> EventTypeProductCreated
            local const_name
            const_name=$(echo "$schema_name" | sed 's/Event$//' | sed 's/^/EventType/')
            echo "	${const_name} = \"${schema_name}\"" >> "$output_file"
        fi
    done
    
    echo ")" >> "$output_file"
    echo "" >> "$output_file"
    
    # Generate sealed Event interface
    cat >> "$output_file" << 'EOF'
// Event is a sealed interface that all event types must implement.
// This enables exhaustiveness checking when using type switches.
type Event interface {
	isEvent() // unexported method seals the interface
}
EOF

    # Implement Event interface for each event type
    for schema in "$AVRO_DIR"/*.avsc; do
        local schema_name
        schema_name=$(jq -r '.name' "$schema" 2>/dev/null || echo "")
        
        if [[ "$schema_name" == *"Event" ]]; then
            echo "" >> "$output_file"
            echo "func (*${schema_name}) isEvent() {}" >> "$output_file"
        fi
    done
    
    # Generate Topic constants from AsyncAPI
    echo "" >> "$output_file"
    echo "// Topic constants - Kafka topics from AsyncAPI spec" >> "$output_file"
    echo "const (" >> "$output_file"
    
    local topics
    topics=$(yq eval '.channels | keys | .[]' "$ASYNCAPI_FILE" 2>/dev/null || echo "")
    
    for topic in $topics; do
        # catalog.product.events -> TopicCatalogProductEvents
        local const_name
        const_name=$(echo "$topic" | sed 's/\./ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2)); print "Topic"$0}' | tr -d ' ')
        echo "	${const_name} = \"${topic}\"" >> "$output_file"
    done
    
    echo ")" >> "$output_file"
    echo "" >> "$output_file"
    
    # Generate SchemaName constants
    echo "// Schema name constants - Avro schema full names (namespace.name)" >> "$output_file"
    echo "const (" >> "$output_file"
    
    for schema in "$AVRO_DIR"/*.avsc; do
        local schema_name namespace
        schema_name=$(jq -r '.name' "$schema" 2>/dev/null || echo "")
        namespace=$(jq -r '.namespace' "$schema" 2>/dev/null || echo "")
        
        if [[ "$schema_name" == *"Event" ]] && [[ -n "$namespace" ]]; then
            local full_name="${namespace}.${schema_name}"
            # ProductCreatedEvent -> SchemaNameProductCreated
            local const_name
            const_name=$(echo "$schema_name" | sed 's/Event$//' | sed 's/^/SchemaName/')
            echo "	${const_name} = \"${full_name}\"" >> "$output_file"
        fi
    done
    
    echo ")" >> "$output_file"
    echo "" >> "$output_file"
    
    # Generate TypeRegistrations
    generate_type_registrations "$output_file"
    
    log "Generated: $output_file"
}

# Generate TypeRegistrations array
generate_type_registrations() {
    local output_file="$1"
    
    cat >> "$output_file" << 'EOF'
// TypeRegistration contains schema registration data for TypeMapping.
type TypeRegistration struct {
	GoType     reflect.Type
	SchemaJSON []byte
	SchemaName string
	Topic      string
}

// TypeRegistrations contains all event type registrations.
// Use this to register all schemas in your microservice.
var TypeRegistrations = []TypeRegistration{
EOF

    local default_topic
    default_topic=$(yq eval '.channels | keys | .[0]' "$ASYNCAPI_FILE" 2>/dev/null || echo "")
    local topic_const_name
    topic_const_name=$(echo "$default_topic" | sed 's/\./ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2)); print "Topic"$0}' | tr -d ' ')
    
    for schema in "$AVRO_DIR"/*.avsc; do
        local schema_name namespace
        schema_name=$(jq -r '.name' "$schema" 2>/dev/null || echo "")
        namespace=$(jq -r '.namespace' "$schema" 2>/dev/null || echo "")
        
        if [[ "$schema_name" == *"Event" ]] && [[ -n "$namespace" ]]; then
            # ProductCreatedEvent -> SchemaNameProductCreated
            local schema_const_name
            schema_const_name=$(echo "$schema_name" | sed 's/Event$//' | sed 's/^/SchemaName/')
            # product_created -> ProductCreated
            local basename_noext
            basename_noext=$(basename "$schema" .avsc)
            local schema_var_name
            schema_var_name=$(echo "$basename_noext" | sed -E 's/(^|_)([a-z])/\U\2/g')
            
            cat >> "$output_file" << EOF
	{
		GoType:     reflect.TypeOf(${schema_name}{}),
		SchemaJSON: ${schema_var_name}CombinedSchema,
		SchemaName: ${schema_const_name},
		Topic:      ${topic_const_name},
	},
EOF
        fi
    done
    
    echo "}" >> "$output_file"
}

# Copy and embed schemas
generate_schema_embeddings() {
    log "Generating schema embeddings..."
    
    # Copy AsyncAPI spec
    cp "$ASYNCAPI_FILE" "$OUTPUT_DIR/asyncapi.yaml"
    
    # Copy Avro schemas
    cp "$AVRO_DIR"/*.avsc "$OUTPUT_DIR/schemas/"
    
    local output_file="$OUTPUT_DIR/schemas.gen.go"
    
    cat > "$output_file" << EOF
// Code generated by generate-events.sh. DO NOT EDIT.
package $PACKAGE

import _ "embed"

//go:embed asyncapi.yaml
var AsyncAPISpec []byte

EOF

    # Embed individual schemas
    for schema in "$AVRO_DIR"/*.avsc; do
        local basename_noext varname
        basename_noext=$(basename "$schema" .avsc)
        varname=$(echo "$basename_noext" | sed -E 's/(^|_)([a-z])/\U\2/g')
        
        echo "//go:embed schemas/${basename_noext}.avsc" >> "$output_file"
        echo "var ${varname}Schema []byte" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # Generate combined schemas (EventMetadata inlined)
    if [ -f "$AVRO_DIR/event_metadata.avsc" ]; then
        echo "// Combined schemas with EventMetadata inlined for Avro serialization" >> "$output_file"
        echo "" >> "$output_file"
        
        local metadata_schema
        metadata_schema=$(cat "$AVRO_DIR/event_metadata.avsc")
        
        for schema in "$AVRO_DIR"/*.avsc; do
            local basename_noext
            basename_noext=$(basename "$schema" .avsc)
            
            # Skip EventMetadata itself
            [ "$basename_noext" = "event_metadata" ] && continue
             
            # Only process event schemas
            if [[ "$basename_noext" == *"_created" ]] || [[ "$basename_noext" == *"_updated" ]] || [[ "$basename_noext" == *"_event" ]]; then
                local event_schema combined_schema varname
                event_schema=$(cat "$schema")
                
                # Inline EventMetadata type reference
                combined_schema=$(echo "$event_schema" | jq --argjson metadata "$metadata_schema" '
                    walk(
                        if type == "object" then
                            if has("type") and .type == "com.ecommerce.events.EventMetadata" then
                                . + {type: ($metadata | del(.namespace))}
                            elif has("type") and (.type | type == "object") and (.type.type == "record") then
                                .type = (.type | del(.namespace))
                            else
                                .
                            end
                        else
                            .
                        end
                    )
                ')
                
                # Save combined schema
                echo "$combined_schema" > "$OUTPUT_DIR/schemas/${basename_noext}_combined.json"
                
                # Add to Go file
                varname=$(echo "$basename_noext" | sed -E 's/(^|_)([a-z])/\U\2/g')
                echo "//go:embed schemas/${basename_noext}_combined.json" >> "$output_file"
                echo "var ${varname}CombinedSchema []byte" >> "$output_file"
                echo "" >> "$output_file"
            fi
        done
    fi
    
    log "Generated: $output_file"
}

# Main
main() {
    echo "=========================================="
    echo "Event Code Generator"
    echo "=========================================="
    echo "AsyncAPI: $ASYNCAPI_FILE"
    echo "Avro Dir: $AVRO_DIR"
    echo "Output:   $OUTPUT_DIR"
    echo "Package:  $PACKAGE"
    echo "=========================================="
    echo ""
    
    check_tools
    create_output_dir
    generate_avro_types
    generate_constants
    generate_schema_embeddings
    
    echo ""
    log "Code generation complete!"
    echo ""
    echo "Generated files:"
    ls -la "$OUTPUT_DIR"/*.go 2>/dev/null || true
}

main "$@"
